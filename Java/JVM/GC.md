# GC

## 垃圾标记算法

### 引用计数

解决不了循环引用。

### 可达性分析算法

将对象的引用关系看作一个图，选定**活动的对象**作为`GC Roots`，从`GC Roots`出发，根据引用链，计算对象是否是从`GC Roots`可以遍历到的。如果一个对象从`GC Roots`不可达，那么被认为是可回收的对象。

`GC Roots`：

* 虚拟机栈中正在引用的对象。
* 本地方法栈中正在引用的对象。
* 静态属性引用的对象。
* 方法区常量引用的对象。



## 垃圾回收算法

### 标记清除算法

直接标记，然后清除。会产生碎片。

### 复制算法

在**From**区域进行标记需要回收的对象，将保留的对象全部复制到**TO**区域，清空**From**区域。

会浪费一倍的内存。

### 标记压缩算法

标记需要回收的对象，回收后重新排列对象，避免产生碎片。



## 分代

### 新生代

分为`Eden`、`From Survivor`、`To Survivor`三个区域。`From Survivor`和`To Survivor`两个区域大小一致，是为了实现复制算法进行垃圾回收。

`Eden`区和`Survivor`区默认是8：1的大小比例。

回收使用复制算法。

默认超过15代对象会进入老年代。

大对象默认不会进入新生代，会默认直接进入老年代。

触发**Minor GC**。

### 老年代

回收使用标记整理算法。

新生代回收时需要向新生代进行担保。

触发**Full GC**。